#!/usr/bin/env bash
#--------------------------#
#  ██      ██████  ██████  #
#  ██████    ██    ████    #
#  ██████    ██    ██████  #
#__________________________#
# bash text editor
# cos.... Why the fuck not?

# Terminal Functions

setup_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[2J\e[1;%sr' "$max_lines"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Only clear the scrolling window (dir item list).
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_lines"
}

get_term_size() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r LINES COLUMNS < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_lines=LINES-2))
}

get_cursor_pos() {
    IFS='[;' read -p $'\e[6n' -d R -rs _ CTy CTx _
}

get_visual_len() { # [!] Improvements need to be made
    # A regular charcter class was used instead
    # of a posix of POSIX bracket expression for
    # pucntuations and other charcetrs
    # since
    # [[:punct:]] would trap emojis (for some reason)
    # [[:ascii:]] would trap ascii control chars
    #             like NULL HT VT
    # Hence I chose to have them hardcoded
    #
    # Passing all charcters to have their visual length
    # measured caused a dramtic drop in performance
    # it took nearly 1.144s to print a line with 100
    # ascii chars
    #
    case $1 in
        [[:alnum:]]|\
        [\!\"#\$%\&\'\(\)\*+\,-./:]|\
        [\;\<=\>\?@\[\\\]\^_\`\{\|]|\
        [\}~£×¿®¬½¼¡«»░▒▓│┤©╣║╗╝¢¥]|\
        [┐└┴┬├─┼╚╔╩╦╠═╬¤┘┌█▄¦▀¯´¬±]|\
        [‗¾¶§÷¸°¨•¹³²■\ ])
            _char_v_len=1 ;;

        *)  
            printf -- '\e7\e[%sH\r\e[K%s' "$LINES" "$1"
            get_cursor_pos
            ((_char_v_len=CTx-1))
            printf '\r\e[K\e8'
        ;;
    esac
}

print_ERR_and_die() {
    # Thank you whetu
    # Print error message to stderr
    printf -- '\e[38;5;9m%s\e[m\n'\
              "$1" >&2
    exit 1
}

print_line() {
    local line="${file[$1]}"
    [[ -z "$line" ]] && return

    local _line_v_len=0
    local s=0
    local e=0
    [[ "$Fy" == "$1" ]] && {
        s=$Fx
        while get_visual_len "${line:s:1}" ; do
            ((_char_v_len + _line_v_len >= Tx)) && break
            ((_line_v_len += _char_v_len))
            ((--s < 0)) && break
        done
        Tx=$((s==Fx ? _char_v_len : _line_v_len))
        s=$((s<=0 ? 0 : s+1))
        e=$((Fx+1))
    }

    while get_visual_len "${line:e:1}" ; do
        ((_line_v_len += _char_v_len))
        ((_line_v_len >= COLUMNS)) && break
        ((++e >= ${#line})) && break
    done

    printf '\r\e[K%s' "${line:s:e-s}"
}

display_buffer() {
    local l
    page_start=0
    page_end=$((page_start+max_lines))
    for((l=page_start;l<page_end;l++)){
        print_line "$l"
        ((l+1 < page_end)) && printf '\n'
    }
}

reload_screen() {
    clear_screen
    display
    status
}


main() {
    [[ $1 == -v ]] && {
        printf '%s\n' "BTE 0.1"
        exit
    }

    get_term_size

    # To stop read from waiting indefinetly for a character input
    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.5)

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    trap 'reset_terminal' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; redraw' WINCH

    setup_terminal
    redraw

    mapfile -t file < "./Makefile"

    Fx=1
    Fy=3
    Tx=30
    Ty=4
    display_buffer
    printf '\e[%s;%sH' "$Ty" "$Tx"
    read -rsn 1

    exit
}

main "$@"
