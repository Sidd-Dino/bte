#!/usr/bin/env bash
#--------------------------#
#  ██      ██████  ██████  #
#  ██████    ██    ████    #
#  ██████    ██    ██████  #
#__________________________#
# bash text editor
# cos.... Why the fuck not?

# Terminal Functions {{{

setup_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[2J\e[1;%sr' "$max_lines"

    # Hide echoing of user input
    #stty -echo
}

reset_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Only clear the scrolling window (dir item list).
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_lines"
}

get_term_size() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r LINES COLUMNS < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_lines=LINES-3))
}

get_cursor_pos() {
    # Usage: get_cursor_pos
    IFS='[;' read -p $'\e[6n' -d R -rs _ term_y term_x _
}

get_char_disp_length() {
    #save cursor
    printf '\e7\e[%sH\e[2K'\
            "$LINES"
    
    printf "%s" "$1"
    get_cursor_pos
    char_disp_length=$((term_x-1))
}

# }}}

# Display Management Functions {{{

print_ERR_and_die() {
    #* Thank you whetu

    # Print error message to stderr
    printf -- '\e[38;5;9m%s\e[m\n'\
              "$1" >&2
    exit 1
}

print_line() {
    
}

display_buffer() {
    h=
}

reload_screen() {
    clear_screen
    display_buffer
    status_screen
}
# }}}

# Text Navigation Functions {{{

move_right() {
    trash=
}

move_left() {
    trash=
}

move_up() {

    trash=
}

move_down() {
    trash=
}

# }}}

# Text Modification Functions {{{

insert() {
    trash=
}

delete() {
    trash=
}

backspace() {
    trash=
}

# }}}

# File Handling Functions {{{

# }}}

# UI Functions {{{

key() {
    local special_keys

    [[ $1 == $'\e' ]] && {
        special_keys+=${1}

        # \e A
        # \e [ A
        # \e [ 6 ~
        # \e [ 2 0 ~
        # \e [ 1 ; 5~
        # \e [ 1 ; 5C
        # -- - - - --
        #  1 2 3 4 5

        #* read 2
        read "${read_flags[@]}" -srn 1
        special_keys+=${REPLY}

        [[ $REPLY == $'[' ]] && {
            #* read 3
            read "${read_flags[@]}" -srn 1
            special_keys+=${REPLY}

            [[ ${REPLY} == [0-9] ]] && {
                #* read 4
                read "${read_flags[@]}" -srn 1
                special_keys+=${REPLY}

                [[ ${REPLY} == [[:digit:]] ]] && {
                    read "${read_flags[@]}" -srn 1 _
                    special_keys+="~"
                }

                [[ ${REPLY} == ";" ]] && {
                    read "${read_flags[@]}" -srn 2
                    special_keys+=${REPLY}
                }
            }
        }

    }

    case "${special_keys:-$1}" in

        # Text Navigation
        #-=========================================

        # Move Cursor Right
        # 'C' is what bash sees when the right arrow is pressed
        # ('\e[C' or '\eOC').
        "${bte_scroll_right_1:=$'\e[C'}"|\
        "${bte_scroll_right_2:=$'\eOC'}")
            move_right
        ;;

        # Move Cursor Left
        # 'D' is what bash sees when the left arrow is pressed
        # ('\e[D' or '\eOD').
        "${bte_scroll_left_1:=$'\e[D'}"|\
        "${bte_scroll_left_2:=$'\eOD'}")
            move_left
        ;;

        # Scroll up.
        # 'A' is what bash sees when the up arrow is pressed
        # ('\e[A' or '\eOA').
        "${bte_scroll_up_1:=$'\e[A'}"|\
        "${bte_scroll_up_2:=$'\eOA'}")
            move_up
        ;;

        # Scroll down.
        # 'B' is what bash sees when the down arrow is pressed
        # ('\e[B' or '\eOB').
        "${bte_scroll_down_1:=$'\e[B'}"|\
        "${bte_scroll_down_2:=$'\eOB'}")
            move_down
        ;;

        # Text Editing
        #-=========================================

        # TO instert a newline in the text
        "${bte_newline_key:=""}")
        ;;

        # Backspace to remove a character before the cursor
        "${bte_bckspc_key_1:=$'\b'}"|\
        "${bte_bckspc_key_2:=$'\177'}")
        ;;

        # Delete key to remove the character under the cursor
        "${bte_delete_key:=$'\e[3~'}")
        ;;
        
        # Tab key to add 4 spaces
        "${bte_tab_key:=$'\t'}")
        ;;

        # A-Z , a-z , 0-9 and special charcters to insert into
        # the text
        [[:alnum:]] |\
        [[:punct:]] |\
        " ")
        ;;

        # Editor Functionality
        #-=========================================

        "${WRITE_TO_FILE_KEY:=$'\017'}")
            write_to_file
            status_line
        ;;

        # Ctrl+x to quit
        "${QUIT_KEY:=$'\030'}")
            exit
        ;;

        # DEBUG Functionality
        #-=========================================

        # F5 key to redraw the current screen
        # Used for debug purposes
        "${bte_redraw:=$'\E[15~'}")
            redraw
        ;;

    esac
}

# }}}

# Misc Functions {{{

init_vars() {
    file_x=0
    file_y=0

    cur_x=
    cur_y=

    term_x=
    term_y=

    buff=()
    buff_lines=

    char_disp_len=
}

# }}}

# Main Functions {{{

main() {
    [[ $1 == -v ]] && {
        printf '%s\n' "BTE 0.1"
        exit
    }

    # To stop read from waiting indefinetly for a character input
    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.5)

    get_term_size
    


    # Trap the exit signal (we need to reset the terminal to a useable state.)
    trap 'reset_terminal' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; redraw' WINCH
    
    setup_terminal
    #redraw

    mapfile -t A < "/home/sidd-dino/Sandbox/bte_test.txt"

    n=40
    printf "%s\n" "${A[$n]}"
    read -rei "${A[$n]}"
    printf "\n%s\n%d->%d" "$REPLY" "${#A[$n]}" "${#REPLY}"
    printf "\n|%*s|\n%s\n%s\n%d->%d"\
           "$((COLUMNS-2))" ""\
           "${A[$n]}" "$REPLY"\
           "${#A[$n]}" "${#REPLY}" >> "/home/sidd-dino/Sandbox/bte_test.txt"
    read -rsn 1
    
    # Vintage infinite loop.
    #for ((;;)); {
    #    read "${read_flags[@]}" -srn 1 && key "$REPLY"

        # Exit if there is no longer a terminal attached.
    #    [[ -t 1 ]] || exit 1
    #}
}

# }}}

main "$@"

# vim: set tabstop=4 shiftwidth=4 expandtab foldmethod=marker:
