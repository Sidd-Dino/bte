#!/usr/bin/env bash
#--------------------------#
#  ██      ██████  ██████  #
#  ██████    ██    ████    #
#  ██████    ██    ██████  #
#__________________________#
# bash text editor
# cos.... Why the fuck not?

setup_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[2J\e[1;%sr' "$max_lines"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Only clear the scrolling window (dir item list).
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[2J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_lines"
}

get_term_size() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r LINES COLUMNS < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_lines=LINES-2))
}

get_visual_len() {
    # [!] Improvements need to be made
    #
    # A regular charcter class was used instead
    # of a posix of POSIX bracket expression for
    # pucntuations and other charcetrs
    # since
    # [[:punct:]] would trap emojis (for some reason)
    # [[:ascii:]] would trap ascii control chars
    #             like NULL HT VT
    # Hence I chose to have them hardcoded
    #
    # Passing all charcters to have their visual length
    # measured caused a dramtic drop in performance
    # it took nearly 1.144s to print a line with 100
    # ascii chars
    #
    case "$1" in
        [\!\"#\$%\&\'\(\)\*+\,-./:]|\
        [\;\<=\>\?@\[\\\]\^_\`\{\|]|\
        [\}~£×¿®¬½¼¡«»░▒▓│┤©╣║╗╝¢¥]|\
        [┐└┴┬├─┼╚╔╩╦╠═╬¤┘┌█▄¦▀¯´¬±]|\
        [‗¾¶§÷¸°¨•¹³²■\ ]|\
        $'\e')
            _char_v_len=1
        ;;

        $'\t')
            [[ -v BTE_TAB_LEN ]] && {
                _char_v_len=$BTE_TAB_LEN
                return
            }
        ;;&

        *)
            [[ "${!vlen[*]}" != *"<$1>"* ]] && {
                printf '\e7\e[%sH\r\e[K%s' "$LINES" "$1"
                IFS='[;' read -p $'\e[6n' -d R -rs _ CTy CTx _
                printf '\r\e[K\e8'

                vlen["<$1>"]=$((CTx-1))
            }

            _char_v_len=${vlen["<$1>"]}
        ;;
    esac
}

cli_error() {
    # Thank you whetu
    # Print error message to stderr
    printf -- '[!] %s\n' "$1" >&2
    exit 1
}

tui_error() {
    printf -- '\e[%sH\r\e[2K\e[3%s;4%sm[!] %s\e[m' \
            "$LINES" \
            "0" "1" \
            "$1"
    read -rt "2.5" <> <(:) || :
}


draw_line() {
    # [!] refactoring needed
    #
    # clear the damn line properly
    printf '\e[2K\r'

    # return if buffer[$1] is unset
    (( ${#buffer[$1]} == 0 )) && { printf '\e[2m~\e[m'; return; }

    # Variable:
    #          $1 : holds the index of the line draw_line will display
    #          $2 : holds a flag that determines whether
    #               LnStart and LnEnd should be ignored while displaying
    #               the line
    #
    #        line : holds a string of the line it will display
    #        S, E : holds values that determine the start and end
    #               of the line segement that will be displayed
    # _line_v_len : holds the visual length of the line segment
    #        diff : holds the value that determines the direction
    #               of the offset during the cursor movement portion

    local \
        line="${buffer[$1]}" disp_line \
        S=0 E=0 \
        _line_v_len=0

    # Check to see if the line being displayed
    # is the same as the one being edited
    (( By == "$1" )) && {
        # if the line is empty (has onlly the EOL substitute)
        # set certain value and return
        # to skip pointless calculations
        (( ${#line} == 1 )) && { Tx=1; LnStart=0; LnEnd=1; return; }

        (( Bx <= LnStart )) && LnStart=0
        (( Bx >= LnEnd )) && LnStart=$((LnEnd-1))
        ((S=Bx))
        while get_visual_len "${line:S:1}"; do
            (( _char_v_len+_line_v_len >= COLUMNS )) && break
            ((_line_v_len+=_char_v_len))
            (( --S < LnStart )) && break
        done
        Tx=$(( S == Bx ? _char_v_len : _line_v_len ))
        S=$(( S <= LnStart ? LnStart : S+1 ))
        ((E=Bx+1))
    }

    while get_visual_len "${line:E:1}" ; do
        ((_line_v_len+=_char_v_len))
        (( _line_v_len >= COLUMNS )) && break
        (( ++E >= ${#line} )) && break
    done

    # make certain special charcters easy to render
    disp_line="${line:S:E-S+1}"
    disp_line="${disp_line//$'\t'/$expanded_tab}"
    disp_line="${disp_line//$'\e'/$'\e[7mE\e[m'}"

    # display the line
    printf '%s' "$disp_line"

    (( E < ${#line} )) && printf '\e[30;41m%s\e[m' ">"
    (( S > 0 )) && printf '\r\e[30;41m%s\e[m' "<"
    (( By == "$1" )) && ((LnStart=S, LnEnd=E))
}

draw_page() {
    local old_max_lines=$((PgEnd-PgStart))
    local diff=$((max_lines-old_max_lines))

    ((PgEnd+=diff))

    (( By >= PgEnd )) && PgEnd=$((By+1))
    ((PgStart=PgEnd-max_lines))

    for ((i=PgStart;i<PgEnd;)); do
        draw_line "$i"
        (( ++i < PgEnd )) && printf '\n'
    done
}

status_line() {
    local left="${file_name:-new_buffer}" \
          right="$((By+1)),$((Bx+1))" \
          key

    # left side
    (( modified )) && left+=" [+]"
    case $mode in
        2) left+="[RO]" ;;
        3) left+="[PASTE]" ;;
    esac

    # right side
    (( esc == 1 )) && key+=$'\e'
    (( esc == 2 )) && key+='['
    printf -v right '%q %s' "$key$sk" "$right"

    printf '\e7\e[%sH%s%*s\e[%sH\e[2K\e8'\
            "$((LINES-1))"\
            "$left" "$((COLUMNS-${#left}))" "$right"\
            "$LINES"
}

sync_cursor() {
    Ty=$((By-PgStart+1))
    printf '\e[%s;%sH' "$Ty" "$Tx"
}

redraw() {
    clear_screen
    draw_page
    sync_cursor
    status_line
}



mv_up() {
    (( By > 0 )) && {
        ((Bx=0))
        draw_line "$By"
        ((Bx=PrevBx))

        ((By--))

        if (( Ty > 1 )); then
            printf '\e[A'
        else
            printf '\e[1L'
            ((PgStart--))
            ((PgEnd--))
        fi

        ((LnLen=${#buffer[By]}))
        Bx=$(( Bx>LnLen-1 ? LnLen-1 : Bx ))
        draw_line "$By"
    }
}

mv_down() {
    (( By+1 < buffer_lines )) && {
        ((Bx=0))
        draw_line "$By"
        ((Bx=PrevBx))

        ((By++))

        if (( Ty < max_lines )); then
            printf '\e[B'
        else
            printf '\n'
            ((PgStart++))
            ((PgEnd++))
        fi

        ((LnLen=${#buffer[By]}))
        Bx=$((Bx>LnLen-1 ? LnLen-1 : Bx))
        draw_line "$By"
    }
}

mv_right() {
    if (( Bx+1 < ${#buffer[By]} )); then
        ((Bx++))
        ((PrevBx=Bx))
        draw_line "$By"
    elif (( By != buffer_lines-1 )); then
        ((Bx=0))
        ((PrevBx=Bx))
        mv_down
    fi
}

mv_left() {
    if (( Bx > 0 )); then
        ((Bx--))
        ((PrevBx=Bx))
        draw_line "$By"
    elif (( By != 0 )); then
        ((Bx=${#buffer[By-1]}-1))
        ((PrevBx=Bx))
        mv_up
    fi
}

home() {
    Bx=$((PrevBx=0))
    draw_line "$By"
}

end() {
    Bx=$((PrevBx=${#buffer[By]}-1))
    draw_line "$By"
}

pg_up() {
    (( PgStart == 0 )) && return
    ((Bx=0, PrevBx=0))
    local OldPgEnd=$PgEnd
    PgStart=$((PgStart-max_lines > 0 ? PgStart-max_lines : 0))
    PgEnd=$((PgStart+max_lines))
    (( By >= PgEnd )) && By=$((PgEnd-OldPgEnd+By))
    redraw
}

pg_down() {
    (( PgEnd >= buffer_lines )) && return
    local OldPgStart=$PgStart
    ((Bx=0, PrevBx=0))
    PgStart=$(( PgStart+max_lines >= buffer_lines ?
                PgStart : PgStart+max_lines))
    PgEnd=$((PgStart+max_lines))
    (( By < PgStart )) && By=$((PgStart-OldPgStart+By))
    (( By >= buffer_lines )) && By=$((buffer_lines-1))
    redraw
}



delete() {
    # remove whatever is at By,Bx
    buffer[By]="${buffer[By]::Bx}${buffer[By]:Bx+1}"
    ((PrevBx=Bx))

    # if the EOL substitute gets deleted
    # append the next line to the current one
    # and shift lines up
    # When the lines buffer[By] and buffer[By+1]
    # are joined. The last characetr in buffer[By+1] is
    # ignored, the EOL sub. An EOL is manually added instead.
    # This is to prevent problems occuring when using
    # delete at the end of the last line.
    (( Bx == ${#buffer[By]} )) && {
        buffer=( "${buffer[@]::By}" \
                 "${buffer[By]}${buffer[By+1]::-1} " \
                 "${buffer[@]:By+2}" )
        ((buffer_lines=${#buffer[@]}))

        for ((i=By;i<PgEnd;)); do
            draw_line "$i"
            (( ++i < PgEnd )) && printf '\n'
        done

        return
    }

    draw_line "$By"

    ((modified=1))
}

backspace() {
    # during the split
    # no matter what value Bx holds, the EOF substitute
    # > is never in part1
    # > is always in part2
    local part1="${buffer[By]:: Bx-1}" \
          part2="${buffer[By]:Bx}"

    # if used at the start of a line
    (( Bx == 0 )) && {
        # do nothing if at 0,0 in buffer
        (( By == 0 )) && return

        ((By--))
        ((Bx=${#buffer[By]}-1))
        ((PrevBx=Bx))
        buffer=( "${buffer[@]::By}" \
                 "${buffer[By]::-1}$part1 " \
                 "${buffer[@]:By+2}" )
        ((buffer_lines=${#buffer[@]}))

        printf '\e[A'
        for ((i=By;i<PgEnd;)); do
            draw_line "$i"
            (( ++i < PgEnd )) && printf '\n'
        done

        return
    }

    # if used anywhere else
    buffer[By]="$part1$part2"
    ((Bx--))
    ((PrevBx--))
    draw_line "$By"

    ((modified=1))
}

tab() {
    # the tab fucntion is seperate from the insert
    # function since it needs to process the passed value
    # and on of the passed values is Z
    # Diffrentiating between
    # Z(meant as a tab) and Z(meant as a character)
    # would require a few pointless things to keep track of
    # hence another fucntion
    local tab="$expanded_tab"
    [[ $1 == Z ]] && tab=$'\t'
    buffer[By]="${buffer[By]:: Bx}$tab${buffer[By]:Bx}"
    ((Bx+=${#tab}))
    ((PrevBx=Bx))
    draw_line "$By"

    ((modified=1))
}

newline() {
    # break the line into two at By,Bx
    buffer=( "${buffer[@]::By}"
             "${buffer[By]::Bx} "
             "${buffer[By]:Bx}"
             "${buffer[@]:By+1}" )

    ((By++, Bx=0, PrevBx=0, buffer_lines++))
    (( Ty == max_lines )) && ((PgStart++, PgEnd++))

    printf '\e[1L'
    draw_line "$((By-1))"
    printf '\n'
    draw_line "$By"

    ((modified=1))
}

insert() {
    buffer[By]="${buffer[By]::Bx}$1${buffer[By]:Bx}"
    ((Bx++, PrevBx=Bx))
    draw_line "$By"

    ((modified=1))
}

paste_mode() {
    clear_screen
    printf '\e[1;1H%s'
    mapfile -t paste_input
}


handle_file() {
    file_path="$*"
    file_name="${1##*/}"

    [[ -a "$file_path" ]] && {
        [[ -d "$file_path" ]] && cli_error "$file_path is a directory"
        [[ ! -r "$file_path" ]] && cli_error "$file_path can't be read"
        [[ ! -w "$file_path" ]] && mode=2

        [[ -b "$file_path" || -c "$file_path" ||\
           -p "$file_path" || -S "$file_path" ]] && \
            cli_error "bte cant handle $file_path"

        mapfile -t buffer < "$file_path"
    }

    buffer_lines=$(( ${#buffer[*]} == 0 ? 1 : ${#buffer[*]} ))

    # an empty charcter is added at the end of
    # the line to act as a substitute for an
    # EOL character
    local i
    for((i=0;i<buffer_lines;i++)){
        buffer[$i]="${buffer[i]} "
    }
}

write_to_file() {
    local input="$file_path"

    printf '\e7\e[%sH' "$LINES"


    while :; do
        [[ -f "$input" ]] && type=' F '
        [[ -d "$input" ]] && type=' D '
        [[ -a "$input" ]] || type=' N '

        IFS= read -rsn 1 -p $'\r\e[K'"[$type] $input" rin
        case $rin in
            $'\177'|$'\b')
                input="${input%?}"
                unset c comp
            ;;

            $'\t')
                [[ -z ${comp[0]} ]] && {
                    set -- "$input"*
                    comp=( "$@" )
                }

                [[ -n ${comp[c]} ]] && {
                    input=${comp[c]}
                    ((c=c >= ${#comp[@]}-1 ? 0 : ++c))
                }

                [[ -d "$input" ]] && {
                    (( ${#comp[@]}==1 )) && {
                        input+='/'
                        unset c comp
                    }
                }
            ;;

            $'\e')
                break
            ;;

            "~")
                input+=$HOME
            ;;

            "")
                { :>"$input" ; } &>/dev/null && {
                    for ln in "${buffer[@]}"; do
                        printf -- '%s\n' "${ln%?}" >> "$input"
                    done

                    file_path="$input"
                    file_name="${input##*/}"

                    modified=0

                    break
                }

                tui_error "Unable to write to file"
            ;;

            *)
                input+=$rin
                unset c comp
            ;;
        esac
    done

    unset c comp

    printf '\e[2K\e8'
}

dbug() { declare -p vlen >> log ; }
quit() { exit ; }

key() {

    #  variable primarily used during input proccessing
    #  $1  : holds the latest character read from stdin
    #  sk  : holds all the charters that come after an
    #        escape charcter and 
    #  esc : holds a numerical representaion of certain
    #        escape charcter formats
    #          \e  : 1
    #          \e[ : 2
    #
    #  |  Input  | esc |  sk  |    $1     |
    #  | \eA     | \e  |      |     A     |
    #  | \e[A    | \e  |      |     A     |
    #  | \e[6~   | \e[ | 6    |     ~     |
    #  | \e[20~  | \e[ | 20   |     ~     |
    #  | \e[1;5~ | \e[ | 1;5  |     ~     |
    #  | \e[1;5C | \e[ | 1;5  |     C     |

    local func

    case "$sk$1$esc$mode" in
        ${BTE_KEY_SCROLL_UP1:=k02}|\
        ${BTE_KEY_SCROLL_UP2:=A2?}|\
        ${BTE_KEY_SCROLL_UP3:=OA1?})    func=mv_up    ;;

        ${BTE_KEY_SCROLL_DOWN1:=j02}|\
        ${BTE_KEY_SCROLL_DOWN2:=B2?}|\
        ${BTE_KEY_SCROLL_DOWN3:=OB1?})  func=mv_down  ;;

        ${BTE_KEY_SCROLL_RIGHT1:=l02}|\
        ${BTE_KEY_SCROLL_RIGHT2:=C2?}|\
        ${BTE_KEY_SCROLL_RIGHT3:=OC1?}) func=mv_right ;;

        ${BTE_KEY_SCROLL_LEFT1:=h02}|\
        ${BTE_KEY_SCROLL_LEFT2:=D2?}|\
        ${BTE_KEY_SCROLL_LEFT3:=OD1?})  func=mv_left  ;;

        ${BTE_KEY_LINE_END1:=F2?}|\
        ${BTE_KEY_LINE_END2:=4~2?})     func=end    ;; # go to end of line
        ${BTE_KEY_LINE_HOME1:=H2?}|\
        ${BTE_KEY_LINE_HOME2:=1~2?})    func=home   ;; # go to start of line

        ${BTE_KEY_PG_UP:=5~2?})         func=pg_up   ;; # go up a page
        ${BTE_KEY_PG_DOWN:=6~2?})       func=pg_down ;; # go down a page

        P21|3~21)       func=delete     ;;  # remove a character before the
                                            # cursor
        $'\b'01|\
        $'\177'01)      func=backspace  ;;  # remove the character at the
                                            # cursor

        $'\t'01|Z21)    func=tab        ;;  # insert spaces on tab
                                            # and the literal tab character on
                                            # shift+tab

        01)             func=newline    ;;  # break the current line at cursor
                                            # on enter
        [[:alnum:]]01|\
        [[:punct:]]01|\
        \ 01)           func=insert     ;;  # insert a character before the
                                            # cursor

        p1?) func=paste_mode    ;;  # paste mode
        w1?) func=write_to_file ;;  # write buffer to file
        r1?) func=redraw        ;;  # redraw the screen
        q1?) func=quit          ;;  # quit bte

        D1?) func=dbug          ;;  # debug function

        # handle esacape charcters
        $'\e'*) esc=1 ;;
         '[1'*) esc=2 ;;
             *) sk+="$1" ;;
    esac

    # if func has been assigned a function name
    # call the fucntion stored in func with k as it's argument
    [[ -n "$func" ]] && { "$func" "$1"; func= ; esc=0; sk= ; }

    # set the default values of esc and sk if $1 is an
    # enter has been passed
    [[ "$1" == '' ]] && { esc=0; sk= ; }

    sync_cursor
    status_line
}

setup_bte() {
    # Tx Ty        : Terminal x and y position
    # vlen         : An associative array that has charcters
    #                associated to their respective vlen
    # tab_len      : holds the display length of \t to
    #                have the length of exapnded tab and \t
    #                be visually customisable
    # tab_char     : acts as a visual replacement for
    #                \t when being printed
    # mode         : defines the mode bte is in
    #                availablle mode :
    #                 1    read and write mode
    #                 2    read only mode
    # modified     : a simple flag that shows if the file has
    #                modified
    # file_path    : holds the path of the file in buffer
    # file_name    : holds the name of the file in buffer
    # buffer       : holds the content of the file passed
    #                or will be empty if no file passed
    # buffer_lines : the number of lines in buffer
    #                an empty buffer will always have
    #                to start from
    # Bx, By       : position in buffer where the edits get carried out
    # PrevBx       : mainly used during navigation of buffer vertically
    #                to make it a bit user friendly

    Tx=1 Ty=1

    declare -gA vlen

    get_visual_len $'\t'
    printf -v expanded_tab "%${_char_v_len}s"

    mode=1
    sk=
    esc=0

    modified=0

    file_path=
    file_name=
    buffer=()
    buffer_lines=0
    Bx=0 By=0
    PrevBx=0
    PgStart=0 PgEnd=$max_lines
    LnStart=0 LnEnd=$COLUMNS
}


main() {
    [[ $1 == '-v' ]] && {
        printf '%s\n' 'BTE (dev)'
        exit
    }

    get_term_size
    setup_bte
    handle_file "$*"

    # To stop read from waiting indefinetly for a character input
    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.5)

    trap 'reset_terminal' EXIT          # reset the terminal on exit
    trap 'exit' INT
    trap 'get_term_size; redraw' WINCH  # handle window resize events

    setup_terminal
    redraw

    for ((;;)) {
        read "${read_flags[@]}" -rsn 1 && key "$REPLY"

        # Exit if there is no longer a terminal attached
        [[ -t 1 ]] || exit 1
    }
}

main "$@"
